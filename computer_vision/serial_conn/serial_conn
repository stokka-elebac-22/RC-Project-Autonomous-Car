#!/usr/bin/env python

"""serial_conn.py: Serial communication module to interface with RC-card."""

# __author__ = "Asbjørn Stokka"
# __copyright__ = "Copyright 2023, DATBAC23"
# __credits__ = ["Asbjørn Stokka"]
# __license__ = "Apache-2.0"
# __version__ = "0.1.0"
# __maintainer__ = "Asbjørn Stokka"
# __email__ = "asbjorn@maxit-as.com"
# __status__ = "Testing"

import threading
import queue
import time
import serial
import sys, glob
import datetime
analog_data = []

class Control_system_serial():
    def __init__(self, current_data):
        self.current_data = current_data
        self.uC_messages = []  # Data sent over serial, for debugging purposes
        self.outgoing_commands = queue.Queue()  # Queue for commands to the serial_thread
        self.connected = False

    """ Establish serial connection
        :raises No Errors:
            Raises no errors, but closes port if it is open
        :returns:
            Returns True or False (connected)
    """
    def connect(self, port, baud):
        try:
            self.serial_port = serial.Serial(port, baud, timeout=1)
            if self.serial_port.isOpen():
                self.serial_port.close()
                #print(self.serial_port.name, 'is open')
                #return False
            self.serial_port.open()
            self.connected = True
            self.serial_thread = threading.Thread(target=self.handle_serial, args=(self.serial_port, self.outgoing_commands, self.uC_messages))
            self.serial_thread.start()
            return True
        except IOError: # if port is already opened, close it and open it again and print message
            self.connected = False
            self.serial_port.close()
            print ("port was already open, closed it!")

        return False

    def send_command(self, command):
        self.outgoing_commands.put(command)  # send command to thread
        time.sleep(1)  # Make sure the thread has time to read the entire message

    def write_serial(self, command):
        self.serial_port.write(command.encode('utf-8'))  # send command / info through serial interface

    """ Convert hex value to ASCII code
        :raises No Errors:
            Currently no error handling
        :returns:
            Returns ASCII code
    """
    def hexascii2int(self, hex_teikn):
        if '0' <= hex_teikn <= '9':
            return (int(ord(hex_teikn) - 48))  # ASCII-code for '0' is 0x30 = 48
        elif 'A' <= hex_teikn <= 'F':
            return (int(ord(hex_teikn) - 55))  # ASCII-code for 'A' is 0x41 = 65

    #-------------------------------------------------------------------------
    # Code for continously read the serial port while connected.
    # Read data will be parsed and added to a list.
    # Close the serial port in the end
    #-------------------------------------------------------------------------
    def handle_serial(self, serial_port, command_que, messages):
        running = True
        pos = 0
        new_command = ""
        test = ""
        teikn = ""
        while running == True:
            # while serieport.inWaiting() > 0:
            # teikn = str(serieport.read(1), encoding='utf-8')  # Les eitt teikn.  #KT La til convert til str
            line = []                                           # Vil blokkera/henga til det er kome noko aa lesa
            c = serial_port.read(1)
            line.append(c)
            test += str(c, encoding="utf-8")
            if c == b'\n':
                self.check_message(test)
                if (line != b'\n'):
                    messages.append(test)
                test = ""
                line = []

            try:
                new_command = command_que.get(block=False)
                self.write_serial(new_command)
                new_command = ""
            except Exception:
                pass

            if new_command == 's':
                running = False

        while teikn != '\x03':
            teikn = str(serial_port.read(1), encoding='utf-8')
            messages.append(teikn)
        serial_port.close()
        print(serial_port.name, 'is closed')

    def check_message(self, new_line):
        """ Checks incomming line for data / info and appends
            :raises No Errors:
                Currently no error handling
            :returns:
                Returns nothing, but adds data to lists
        """
        pos = new_line.find("DATA")
        if (pos > 0):
            new_line = new_line[pos:].split(";")
            try:
                pass
            except:
                pass
            return
        pos = new_line.find("LOCAL")
        if (pos >= 0):
            new_line = new_line[pos:].split(";")
            try:
                pass
            except:
                pass
            return

    def get_serial_ports(self):
        """ Lists serial port names
            :raises EnvironmentError:
                On unsupported or unknown platforms
            :returns:
                A list of the serial ports available on the system
        """
        if sys.platform.startswith('win'):
            ports = ['COM%s' % (i + 1) for i in range(256)]
        elif sys.platform.startswith('linux') or sys.platform.startswith('cygwin'):
            # this excludes your current terminal "/dev/tty"
            ports = glob.glob('/dev/tty[A-Za-z]*')
        elif sys.platform.startswith('darwin'):
            ports = glob.glob('/dev/tty.*')
        else:
            raise EnvironmentError('Unsupported platform')

        result = []
        for port in ports:
            try:
                s = serial.Serial(port)
                s.close()
                result.append(port)
            except (OSError, serial.SerialException):
                pass
        return result

if __name__ == "__main__":
    print("Needs to be imported to be of any use ...")
    # Do nothing